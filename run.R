# Run.R
# This script loads & modifies the K&M and AM data to make it fit for Vision calculations.
# This is the main file to execute for the Bottom Up Net-calculations project. It computes 
# the specific loads per MSR using sparse matrix algebra.
# 
# By Werner van Westering MSc.
# Based on code generated by Tim Lucas.
# Start 28-10-2014
#
# "AaaRRRRRR matey! This be t' author's first real R model. HarrRRR HarrRRR HaRRRRR!"
# "So t' script has some pirate talk in it. ARRRRRR be t' pirate language!"
#
# Abbriviations
# KV   = KleinVerbruikers      (Small Users)
# GV   = GrootVerbruikers      (Large Users)
# WP   = WarmtePomp            (Combined Heat and Power (CHP))
# PV   = PhotoVoltaic
# EV   = Electric Vehicles
# HLD  = HoofdLeiDing         (Major LV line) (Headline is the wrong translation ;))
# LSLD = LaagSpanningsLeiDing
# OSLD = OnderStationsLeiDing
# LV   = Low Voltage
# MSR  = MiddenSpanningsRuimte (Medium-to-low voltage transformer room)


##Initialize ----------------------------------------------------------------------
# Remove all data and set working directory
# rm(list=ls(all=TRUE))
gc(verbose=FALSE)
path = "C:/1. Programmeerwerk/Bottum Up Analyse/2. Data"
setwd(paste0(path,"/7. Output"))
nCPUs = 2

print("--Loading packages--")
# Load packages
library(reshape2)
library(plyr)
library(data.table)
library(slam)       #Used for sparse matrices
library(tictoc)     #Because I am a Matlab person
library(xlsx)
library(ggplot2)
library(doSNOW)
library(utils)

#Load data (To generate this data: run DataPreparation.R)
print("--Loading data--")
# load("Connections_NH_v2.RData")

print("--Defining functions (1/3)--")
# Defines function which calculates peak time per MSR
# Function calculates the total year-profile per MSR per scenario per year, and 
# then finds the time at which the load is mimimum and maximum.
# Note: this function only gives back the time at which this happens. The load itself is calculated
# later per base, EV, PV and WP

ParPeaktimeCalculationperAsset <- function(iter,nparscenarios,KVbaseloadperAsset,GVbaseloadperAsset,KVScenariosperAsset,AllKVtechprofiles,GVScenariosperAsset,AllGVtechprofiles) {
   nAssets = dim(KVScenariosperAsset)[1]
   Outputmatrix = matrix(nrow = nAssets,ncol=2*nparscenarios)
   setTxtProgressBar(pb, iter)
   for(ii in 1:nparscenarios) {
      for(Assetii in 1:nAssets) {
         Assettotalprofile = KVbaseloadperAsset[Assetii,] + GVbaseloadperAsset[Assetii,] +
            AllKVtechprofiles %*% KVScenariosperAsset[Assetii,,(ii+(iter*nparscenarios))] +
            AllGVtechprofiles %*% GVScenariosperAsset[Assetii,,(ii+(iter*nparscenarios))] 
         Outputmatrix[Assetii,ii]               = which.max(Assettotalprofile)          #peaktime
         Outputmatrix[Assetii,nparscenarios+ii] = which.min(Assettotalprofile)          #peaktimemin
      }  
   }
   return(Outputmatrix)
}

FindLoadperAsset <- function(baseloadperAsset,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperAsset,GVScenariosperAsset,peaktimeperAsset) {
   Assetload                = matrix(NA,length(peaktimeperAsset),4)
   KVtempAsset              = AllKVtechprofiles[peaktimeperAsset,] * KVScenariosperAsset
   GVtempAsset              = AllGVtechprofiles[peaktimeperAsset,] * GVScenariosperAsset
   
   indexmatrix = matrix(c(peaktimeperAsset,1:nMSR),nMSR,2)
   Assetload[,baseorder]    = baseloadperAsset[indexmatrix]
   Assetload[,EVorder]      = rowSums(KVtempAsset[,KVEVindex]) + GVtempAsset
   Assetload[,PVorder]      = KVtempAsset[,KVPVindex]
   Assetload[,WPorder]      = KVtempAsset[,KVWPindex] 
   Assetload = c(Assetload)
   return(Assetload)
}

print("--Calculation based on peaktime per MSR (2/3)--")
# Initialise matrices which will hold the peak time and minimum peak time (feedin) per MSR 
MSRpeaktimetemp      = matrix(nrow = nMSR,  ncol = 2*nscenarios)
MSRpeaktime_MSR      = matrix(nrow = nMSR,  ncol = nscenarios)
MSRpeaktimemin_MSR   = matrix(nrow = nMSR,  ncol = nscenarios)
HLDpeaktime_MSR      = matrix(nrow = nHLD,  ncol = nscenarios)
HLDpeaktimemin_MSR   = matrix(nrow = nHLD,  ncol = nscenarios)
OSLDpeaktime_MSR     = matrix(nrow = nOSLD, ncol = nscenarios)
OSLDpeaktimemin_MSR  = matrix(nrow = nOSLD, ncol = nscenarios)

print("--> Calculating peak times in network per MSR (2a/3)--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
nparscenarios = nscenarios/nCPUs       #NEED FIX: Does not work if nscenarios/nCPUs is not an integer
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
pb = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
MSRpeaktimetemp = foreach(iter = 0:(nCPUs-1), .packages='slam', .combine=cbind, .verbose=FALSE) %dopar% {
   ParPeaktimeCalculationperAsset(iter,nparscenarios,KVbaseloadperMSR,GVbaseloadperMSR,KVScenariosperMSR,AllKVtechprofiles,GVScenariosperMSR,AllGVtechprofiles)
}

toc()
stopCluster(cl)
close(pb)

# test = foreacht(iter,.combine=cbind,.verbose=FALSE)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist          = rep(c(rep(TRUE,nPVscen*nWPscen*nyears),rep(FALSE,nPVscen*nWPscen*nyears)),nCPUs)
MSRpeaktime_MSR    = MSRpeaktimetemp[,indexlist]
MSRpeaktimemin_MSR = MSRpeaktimetemp[,!indexlist]
rm(MSRpeaktimetemp)

print("--> Cascading peak times per MSR to HLDs (2b/3)--")
# Peak time per HLD is calculated by using MSRtoHLD interconnection matrices
# TO DO!! Account for HLDs which are connected to multiple MSRs
tic()
HLDpeaktime_MSR     = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_MSR)
HLDpeaktimemin_MSR  = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_MSR)
toc()

print("--> Calculating loads per MSR and HLD based on peak times per MSR (2c/3)--")
# Based on the peak times, the minimum and maximum load is then found.
# Initialise  matrices
OSLDload_MSR      = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_MSR   = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_MSR       = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_MSR    = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_MSR       = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_MSR    = matrix(nrow = 4*nHLD, ncol = nscenarios)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
   setTxtProgressBar(progressbar,ii)
   
   # For each scenario, we find the load from AllKVprofiles which corresponds with the peak time per MSR 
   # and multiply this element wise with a vector containing [nEV,nPV,nWP]
   # This gives a matrix tempMSR with dimension [nMSR * ntechprofiles]
   
   #peak load per MSR 
   MSRload_MSR    = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktime_MSR[,ii])
   MSRloadmin_MSR = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktimemin_MSR[,ii])
   #peak load per HLD
   HLDload_MSR    = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],GVScenariosperHLD[,,ii],HLDpeaktime_MSR[,ii])   
   HLDloadmin_MSR = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],GVScenariosperHLD[,,ii],HLDpeaktimemin_MSR[,ii])      
}
toc()
close(progressbar)

print("--> Calculating loads per OSLD based on peak times per MSR (2d/3)--")
# OSLD load is calculated using MSRtoOSLD matrices
# Note: this is only for checking purposes in the model, to check loads per OSLD based on 
# MSR peak time calculations, versus loads per OSLD based on OSLD peak time calculations
indexlist_MSR  = rep(c(TRUE,FALSE,FALSE,FALSE),nMSR)
indexlist_OSLD = rep(c(TRUE,FALSE,FALSE,FALSE),nOSLD)
for (i in 1:4) {
   tempMSRload                       = MSRload_MSR[indexlist_MSR,]
   OSLDload_MSR[indexlist_OSLD,]     = matprod_simple_triplet_matrix(MSRtoOSLD,tempMSRload)
   tempMSRload                       = MSRloadmin_MSR[indexlist_MSR,]
   OSLDloadmin_MSR[indexlist_OSLD,]  = matprod_simple_triplet_matrix(MSRtoOSLD,tempMSRload)
   indexlist_MSR = c(FALSE,indexlist_MSR[-length(indexlist_MSR)])
   indexlist_OSLD = c(FALSE,indexlist_OSLD[-length(indexlist_OSLD)])
}

print("--Calculating peak timeS in network per OSLD--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
nparscenarios = nscenarios/nCPUs
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
pb = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
OSLDpeaktimetemp = foreach(iter = 0:(nCPUs-1), .packages='slam', .combine=cbind,.verbose=FALSE) %dopar% {
   ParPeaktimeCalculationperAsset(iter,nparscenarios,KVbaseloadperOSLD,GVbaseloadperOSLD,KVScenariosperOSLD,AllKVtechprofiles,GVScenariosperOSLD,AllGVtechprofiles)
}
toc()
stopCluster(cl)
close(pb)
# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist = rep(c(rep(TRUE,nPVscen*nWPscen*nyears),rep(FALSE,nPVscen*nWPscen*nyears)),nCPUs)
OSLDpeaktime_OSLD    = OSLDpeaktimetemp[,indexlist]
OSLDpeaktimemin_OSLD = OSLDpeaktimetemp[,!indexlist]
rm(OSLDpeaktimetemp)

# Peak time per MSR and HLD is calculated by using OSLDtoMSR and MSRtoHLD interconnection matrices
tic()
MSRpeaktime_OSLD                            = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktime_OSLD)
MSRpeaktimemin_OSLD                         = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktimemin_OSLD)
MSRpeaktime_OSLD[MSRpeaktime_OSLD==0]       = NA #not all MSRs have an OSLD
MSRpeaktimemin_OSLD[MSRpeaktimemin_OSLD==0] = NA #not all MSRs have an OSLD
HLDpeaktime_OSLD                            = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_OSLD)
HLDpeaktimemin_OSLD                         = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_OSLD)
toc()

# Based on the peak times, the minimum and maximum load is then found.
print("--Calculate loads in network per OSLD--")
# Initialise  matrices
OSLDload_OSLD    = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_OSLD = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_OSLD     = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_OSLD  = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_OSLD     = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_OSLD  = matrix(nrow = 4*nHLD, ncol = nscenarios)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
   setTxtProgressBar(progressbar,ii)
   
   # For each scenario, we find the load from AllKVprofiles which corresponds with the peak time per MSR 
   # and multiply this element wise with a vector containing [SJV,nEV,nPV,nWP]
   # This gives a matrix tempMSR with dimension [nMSR * nprofiles]
   # in the second step, this matrix is truncated so that different profiles which correspond to the same load
   # (e.g. 10 EDSN profiles which all correspond to the 'base' load) are summed up into 1 value
   
   #peak load per OSLD 
   OSLDload_OSLD    = FindLoadperAsset(KVbaseloadperOSLD,GVbaseloadperOSLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperOSLD[,,ii],GVScenariosperOSLD[,,ii],OSLDpeaktime_OSLD[,ii])
   OSLDloadmin_OSLD = FindLoadperAsset(KVbaseloadperOSLD,GVbaseloadperOSLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperOSLD[,,ii],GVScenariosperOSLD[,,ii],OSLDpeaktimemin_OSLD[,ii])
   #peak load per MSR 
   MSRload_OSLD     = FindLoadperAsset(KVbaseloadperMSR,GVbaseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktime_OSLD[,ii])
   MSRloadmin_OSLD  = FindLoadperAsset(KVbaseloadperMSR,GVbaseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktimemin_OSLD[,ii])
   #peak load per HLD
   HLDload_OSLD     = FindLoadperAsset(KVbaseloadperHLD,GVbaseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],GVScenariosperHLD[,,ii],HLDpeaktime_OSLD[,ii])   
   HLDloadmin_OSLD  = FindLoadperAsset(KVbaseloadperHLD,GVbaseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],GVScenariosperHLD[,,ii],HLDpeaktimemin_OSLD[,ii])     
}
toc()
close(progressbar)

# Fix for multiple HLD connections



######################################################### Save results
print("--Saving results--")
setwd(paste0(path,"/7. Output"))

# Save necessary data
save.image("CalculationOutput_NH_v2.RData")
print("--Done!--")

# ##################################Generate a quick (&dirty) plot
# factor = seq(0,30,length=50)           # Newbaseload = baseload * factor
# outcome = numeric(length(factor))
# 
# # For every factor, check the number of overloaded MSR
# for (ii in 1:length(factor)){
#    print(ii)
#    outcome[ii] = table(MSRmax!=0&((MSRload[,1]+MSRloadGV)*factor[ii])>MSRmax)[2]
# }
# d1<-data.frame(basefactor=factor,overbelast=outcome)
# theme_set(theme_gray(base_size = 18)) # vergrooten lettergroottes
# 
# # Write a png
# setwd("C:/Programmeerwerk/Data")
# png("overbelast.png",width=800, height=500)
# qplot(factor,outcome,xlab="Baseload (1 = nu)",ylab="Aantal overbelaste MSR",geom='line',
#       col=I('blue'),size=1,legend=F,main="Overbelaste MSR versus toename baseload")
# geom_line(aes(factor, outcome, colour=I('red')), d1)
# dev.off()

###### For reference, peak time calculations per individual asset
#
# ParPeaktimeCalculationperMSR <- function(iter,nparscenarios) {
#    Outputmatrix = matrix(nrow = nMSR,ncol=2*nparscenarios)
#    setTxtProgressBar(pb, iter)
#    for(ii in 1:nparscenarios) {
#       for(MSRii in 1:nMSR) {
#          MSRtotalprofile = AllKVprofiles %*% ScenariosperMSR[MSRii,,(ii+(iter*nparscenarios))] + GVuse[MSRii,]
#          Outputmatrix[MSRii,ii]               = which.max(MSRtotalprofile)          #peaktime
#          Outputmatrix[MSRii,nparscenarios+ii] = which.min(MSRtotalprofile)          #peaktimemin
#       }  
#    }
#    return(Outputmatrix)
# }
# 
# # Same as above but now per OS field
# ParPeaktimeCalculationperOSLD <- function(iter,nparscenarios) {
#    Outputmatrix = matrix(nrow = nOSLD,ncol=2*nparscenarios)
#    setTxtProgressBar(pb, iter)
#    for(ii in 1:nparscenarios) {
#       for(OSLDii in 1:nOSLD) {
#          OSLDtotalprofile = AllKVprofiles %*% ScenariosperOSLD[OSLDii,,(ii+(iter*nparscenarios))] + GVMSRload[Assetii,]
#          Outputmatrix[OSLDii,ii]               = which.max(OSLDtotalprofile)          #peaktime
#          Outputmatrix[OSLDii,nparscenarios+ii] = which.min(OSLDtotalprofile)          #peaktimemin
#       }  
#    }
#    return(Outputmatrix)
# }

# For reference, code from Werner van Westering
# # scenarios = cbind(base,PVall[,35:51]*PVpeak+EVall[,35:51]*EVpeak+WPall[,35:51]*WPpeak)
# 
# # Calculate loads
# print("--Doing calculations--")
# #Calculate the loads of the whole network
# tic()
# LSLDload     = matprod_simple_triplet_matrix(PC6toLSLD, scenario)    #Calculate LSLD loads
# MSRload      = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDload)    #Calculate MSR loads
# MSRloadGV    = matprod_simple_triplet_matrix(GVtoMSR, GVuse)         #Calculate GV MSR loads
# HLDload      = matprod_simple_triplet_matrix(PC6toHLD, scenario)     #Calculate HLD loads
# #LSLDloadmin  = matprod_simple_triplet_matrix(PC6toLSLD, scenariomin) #Calculate LSLD loads
# #MSRloadmin   = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDloadmin) #Calculate MSR loads
# #MSRloadGVmin = MSRloadGV                                             #Calculate GV MSR loads
# #HLDloadmin   = matprod_simple_triplet_matrix(PC6toHLD, scenariomin)  #Calculate HLD loads
# toc()
# #Elegant, isn't it?
# 
# #Add GV results to KV results
# MSRload[,seq(1,4*nscenarios,by=4)] = MSRload[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGV,nscenarios)
# MSRloadmin[,seq(1,4*nscenarios,by=4)] = MSRloadmin[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGVmin,nscenarios)
# 
# #Check and count capacity problems
# #table(MSRload[,1]>MSRmax)
# #table(MSRmax!=0&MSRload[,1]>MSRmax)
# # table(HLDmax!=0&HLDload[,1]>HLDmax)