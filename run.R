# Run.R
# This script loads & modifies the K&M data to make it fit for Vision calculations.
# This is the main file to execute for the Bottom Up Net-calculations project.
#
# By Werner van Westering MSc.
# Based on code generated by Tim Lucas.
# Start 28-10-2014

# "AaaRRRRRR matey! This be t' author's first real R model. HarrRRR HarrRRR HaRRRRR!"
# "So t' script has some pirate talk in it. ARRRRRR be t' pirate language!"

# Abbriviations
# KV = KleinVerbruikers (Small Users)
# GV = GrootVerbruikers (Large Users)
# WP = WarmtePomp       (Combined Heat and Power (CHP))
# PV = Photovoltaic
# EV = Electric Vehicles

##Initialize ----------------------------------------------------------------------
# Remove all data and set working directory
rm(list=ls(all=TRUE))
setwd("C:/Programmeerwerk/VnDigitaalNetbeheerData/")

# Load packages
library(reshape2)
library(dplyr)
library(data.table)

#Load data (To generate this data: run DataPreparation.R)
load("Connections_NH.RData")

##Start of calculations -----------------------------------------------------------

#Array prealloceren om de Resultaten voor LS_Hld in op te slaan, twee kolommen per jaar voor de min en de max + de base, EV en PV toevoeging (6 kolommen per jaar dus), de verschillende scenario's moeten we denk ik in verschillende resultaatbestanden doen om het overzicht te bewaren

#GENERIEKE FUNCTIE MAKEN OM DE NETVLAKKEN DOOR TE REKENEN
#TODO: -Per netvlak functie ook de kwaliteitsaspecten meenemen (kijken hoe lang een bepaalde belasting optreed en kijken of deze niet te lang optreed voor bepaald netcomponenten)

#Bij deze _bare tabel wordt de tijdsvector eraf gehaald om te kunnen matrixrekenen met de EDSN profielen, daarbij wordt er door 0.9 gedeeld om kW om te zetten naar kVA
EDSN_profiel_uur_max_bare <- sapply(EDSN_profiel_uur_max[,3:12], function(x) as.numeric(x))/0.9 #delen door 0.9 is vanwege de conversie naar kVA
EDSN_profiel_uur_min_bare <- sapply(EDSN_profiel_uur_min[,3:12], function(x) as.numeric(x))/0.9 #delen door 0.9 is vanwege de conversie naar kVA

NetVlakFunctieMax <- function(AantalComponenten, BaseL, EVPenGr, PVPenGr, WPPenGr) {
   
   #INPUTS
   #AantalComponenten; is een lijst met het aantal componenten waarover moet worden geitereerd
   #BaseL; data.frame met BaseL gegevens per Netvlak
   #EVPenGr, PVPenGr, WPPenGr; data.frame met PenetratieGraden per scenario en Netvlak
   
   #Deze functie gaat ervan uit dat de EDSN, EV, PV, en WP belastingprofielen al zijn ingeladen
   
   #OUTPUT
   #Deze functie geeft als Output een matrix met daarin alle voorspellingen per jaar per netvlak component
   
   #Als eerste de resultaten matrix prealloceren
   OutputMatrix <- matrix(ncol = 5*16, nrow = length(AantalComponenten))
   
   #Beginnen met het maken van de BaseL, omdat deze maar een keer hoeft te worden gemaakt
   for (i in 1:length(AantalComponenten)) {
      Baseload <- rowSums(EDSN_profiel_uur_max_bare%*%diag(BaseL[i,2:11]))
      for (Jr in 1:16) {
         Tot_Profiel <- Baseload + EVPenGr[i,Jr+1]*EV_Profiel_uur_max$V1 + PVPenGr[i,Jr+1]*PV_Profiel_uur_max$V1 + WPPenGr[i,Jr+1]*WP_Profiel_uur_max$V1
         
         #Eerste kolom is voor de max
         OutputMatrix[i,5*(Jr-1)+1] <- max(Tot_Profiel) #Jr begint bij 3 dus -2-1 = -3
         #Daarna voor de bijdragen van Baseload, EV, PV, en WP
         MaxIndex <- which.max(Tot_Profiel)
         OutputMatrix[i,5*(Jr-1)+2] <- Baseload[MaxIndex]
         OutputMatrix[i,5*(Jr-1)+3] <- EV_Profiel_uur_max$V1[MaxIndex]*EVPenGr[i,Jr+1]
         OutputMatrix[i,5*(Jr-1)+4] <- PV_Profiel_uur_max$V1[MaxIndex]*PVPenGr[i,Jr+1]
         OutputMatrix[i,5*(Jr-1)+5] <- WP_Profiel_uur_max$V1[MaxIndex]*WPPenGr[i,Jr+1]
         
         #Hier komt ook nog een stuk waarbij de kwaliteitsfactoren van kabels kan worden gecheckt
         
         #Opruimen
         #       rm(Tot_Profiel)
         #       rm(MaxIndex)
      }
      #     rm(Baseload)
   }
   
   return(OutputMatrix)
   
}
NetVlakFunctieMin <- function(AantalComponenten, BaseL, EVPenGr, PVPenGr, WPPenGr) {
   
   #INPUTS
   #AantalComponenten; is een lijst met het aantal componenten waarover moet worden geitereerd
   #BaseL; data.frame met BaseL gegevens per Netvlak
   #EVPenGr, PVPenGr, WPPenGr; data.frame met PenetratieGraden per scenario en Netvlak
   
   #Deze functie gaat ervan uit dat de EDSN, EV, PV, en WP belastingprofielen al zijn ingeladen
   
   #OUTPUT
   #Deze functie geeft als Output een matrix met daarin alle voorspellingen per jaar per netvlak component
   
   #Als eerste de resultaten matrix prealloceren
   OutputMatrix <- matrix(ncol = 5*16, nrow = length(AantalComponenten))
   
   #Beginnen met het maken van de BaseL, omdat deze maar een keer hoeft te worden gemaakt
   for (i in 1:length(AantalComponenten)) {
      Baseload <- rowSums(EDSN_profiel_uur_min_bare%*%diag(BaseL[i,2:11]))
      for (Jr in 1:16) {
         Tot_Profiel <- Baseload + EVPenGr[i,Jr+1]*EV_Profiel_uur_min$V1 + PVPenGr[i,Jr+1]*PV_Profiel_uur_min$V1 + WPPenGr[i,Jr+1]*WP_Profiel_uur_min$V1
         
         #Eerste kolom is voor de max
         OutputMatrix[i,5*(Jr-1)+1] <- min(Tot_Profiel) #Jr begint bij 3 dus -2-1 = -3
         #Daarna voor de bijdragen van Baseload, EV, PV, en WP
         MinIndex <- which.min(Tot_Profiel)
         OutputMatrix[i,5*(Jr-1)+2] <- Baseload[MinIndex]
         OutputMatrix[i,5*(Jr-1)+3] <- EV_Profiel_uur_min$V1[MinIndex]*EVPenGr[i,Jr+1]
         OutputMatrix[i,5*(Jr-1)+4] <- PV_Profiel_uur_min$V1[MinIndex]*PVPenGr[i,Jr+1]
         OutputMatrix[i,5*(Jr-1)+5] <- WP_Profiel_uur_min$V1[MinIndex]*WPPenGr[i,Jr+1]
         
         #Hier komt ook nog een stuk waarbij de kwaliteitsfactoren van kabels kan worden gecheckt
         
         #Opruimen
         #       rm(Tot_Profiel)
         #       rm(MaxIndex)
      }
      #     rm(Baseload)
   }
   
   return(OutputMatrix)
   
}

#TER VOORBEELD GENEREER IK HIER EEN LS_HLD LIJST EN EEN MSR LIJST MET LAAG SCENARIO OM AAN TE GEVEN DAT DIT WERKT

LS_Max_Laag_Scenario <- NetVlakFunctieMax(1:nrow(LS_Hld_BaseL), LS_Hld_BaseL, LS_Hld_PenGr_EV_L, LS_Hld_PenGr_PV_L,  LS_Hld_PenGr_WP_L)
MSR_Max_Laag_Scenario <- NetVlakFunctieMax(1:nrow(MSR_BaseL), MSR_BaseL, MSR_PenGr_EV_L, MSR_PenGr_PV_L, MSR_PenGr_WP_L)

# Stukje code om de kolomnamen toe te voegen aan de resultaten, ik maar eerst een lijst 

KolomNamenJaren <- c("2015", "2016", "2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025", "2026", "2027", "2028", "2029", "2030")
KolomNamenMaxMin <- c("_belasting", "_BaseL_bijdrage", "_EV_bijdrage", "_PV_bijdrage", "_WP_bijdrage")

KolomNamenTabel <- as.vector(sapply(KolomNamenJaren, function(x) paste(x, KolomNamenMaxMin, sep = "")))

colnames(LS_Max_Laag_Scenario) <- KolomNamenTabel
colnames(MSR_Max_Laag_Scenario) <- KolomNamenTabel

#Vervolgens kunnen we de LS_Hld resultaten Tabel aan de gegevens koppelen die wij hebben van de LS_Hld 

#Hieronder laden wij wat gegevens in die ons daarbij kunnen helpen
MS_Stations <- read.csv("MS_stations_Flevoland.csv", sep = ";", dec = ",") #Alle gegevens van alle MSR in Flevoland
LS_Hld_PC6 <- read.table("ls_hld_pc6.csv", sep = ";", header = TRUE, colClasses= "character") #Oude tabel die gebruikt werd om de LS_Hld te koppelen aan de MSR en ook om te kijken welke
LS_Alle_Ld <- read.csv("MSR_FLEVO_LSHLD_Aansl.csv", sep = ";", dec = ",") #Nog een lijst die ons hierbij kan helpen
KabelTypen <- read.csv("kabelgegevens.csv", sep = ";", dec = ",") #Kabeltypen lijst met Inoms erbij die kan worden gebruikt om de Inom van de LS_Hld te bepalen
KabelMatch <- read.csv("kabelgegevens_compl.csv", sep = ";", dec =",") #Hulplijst voor bovenstaande data

#Voor deze LS_Hld lijst moeten wij wat gegevens aan gaan toevoegen omdat hierbij nog niet de MaxInom staat, dit doen we met de KabelTypen en KabelMatch lijst

null_lijst <- which(LS_Hld_PC6$MSR_BEHUIZING == "") 
LS_Hld_PC6$MSR_BEHUIZING[null_lijst] <- unlist(sapply(LS_Hld_PC6$ls_hld_id[null_lijst], function(x) LS_Alle_Ld$NR_Behuizing[which(LS_Alle_Ld$ls_hld_id == x)[1]]))
#Sorteren per meest belastbare kabel
KabelMatch <- KabelMatch[with(KabelMatch, order(-Inom)), ]
#Vervolgens meest belastbare kabel selecteren, voor methode ordering zie http://stackoverflow.com/questions/1568511/how-do-i-sort-one-vector-based-on-values-of-another
BelastbareKabelFunctie <- function (x) {
   TestLijst <- sapply(strsplit(as.character(LS_Alle_Ld$uitvoering[which(LS_Alle_Ld$ls_hld_id %in% x == TRUE)]), "\\+"), "[[", 1)
   if(length(TestLijst) == 0) { return("Geen Match")}
   else {return(as.vector(unlist(TestLijst[order(match(TestLijst, KabelMatch$KabelType))][1])))}
}

#De meest belastbare kabel wordt geselecteerd met behulp van bovenstaande functie
LS_Hld_PC6$KabelType <- sapply(LS_Hld_PC6$ls_hld_id, BelastbareKabelFunctie)
## y[sort(order(y)[x])] zie http://stackoverflow.com/questions/1568511/how-do-i-sort-one-vector-based-on-values-of-another
LS_Hld_PC6$MaxInom <- sapply(LS_Hld_PC6$KabelType, function(x) KabelMatch$Inom[which(KabelMatch$KabelType == x)[1]])

#Nu hebben de kabels een Inom en kunnen we een unieke LS_Hld lijst maken

Unieke_Ls_Hld <- data.frame(ls_hld_id = unique(LS_Hld_PC6$ls_hld_id))

#Vervolgens kunnen aan deze unieke lijst wat gegevens gaan toevoegen die belangrijk zijn
Match_Lijst_LS_hd <- sapply(Unieke_Ls_Hld$ls_hld_id, function(x) match(x, LS_Hld_PC6$ls_hld_id))

Unieke_Ls_Hld$hoofdleiding <- LS_Hld_PC6$hoofdleiding[Match_Lijst_LS_hd]
Unieke_Ls_Hld$lengte <- LS_Hld_PC6$lengte[Match_Lijst_LS_hd]
Unieke_Ls_Hld$aansluitingen <- LS_Hld_PC6$aansluitingen[Match_Lijst_LS_hd]
Unieke_Ls_Hld$MSR_BEHUIZING <- LS_Hld_PC6$MSR_BEHUIZING[Match_Lijst_LS_hd]
Unieke_Ls_Hld$VELD_NR <- LS_Hld_PC6$VELD_NR[Match_Lijst_LS_hd]
Unieke_Ls_Hld$BEV_NORM <- LS_Hld_PC6$BEV_NORM[Match_Lijst_LS_hd]
Unieke_Ls_Hld$BMR_FUNCTIE <- LS_Hld_PC6$BMR_FUNCTIE[Match_Lijst_LS_hd]
Unieke_Ls_Hld$BMR_SUBFUNCTIE <- LS_Hld_PC6$BMR_SUBFUNCTIE[Match_Lijst_LS_hd]
Unieke_Ls_Hld$PC6 <- LS_Hld_PC6$PC6[Match_Lijst_LS_hd]
Unieke_Ls_Hld$KabelType <- LS_Hld_PC6$KabelType[Match_Lijst_LS_hd]
Unieke_Ls_Hld$MaxInom <- LS_Hld_PC6$MaxInom[Match_Lijst_LS_hd]

#Als laatste kunnen wij nu vervolgens de resultatenlijst koppelen aan deze gegevenslijst om per LS_Hld resultaat gegevens te kunnen koppelen 

#Hieronder wordt een lijst waarmee we de gegevens kunnen matchen aan de resultaten lijst, de functie sapply gaat langs alle rijen en past daar de functie match(x, ...) op toe, die de 

ML_Resultaten_LS_HLD_aan_Gegevens <- sapply(LS_Hld_PenGr_EV_H$LS_HLD_ID, function(x) match(x, Unieke_Ls_Hld$ls_hld_id))

#Nu kunnen we aan deze gegevens de eindlijst koppelen, dit zijn dus alle gegevens in totaal

LS_Max_Laag_Scenario <- cbind(Unieke_Ls_Hld[ML_Resultaten_LS_HLD_aan_Gegevens,], LS_Max_Laag_Scenario)

#Nu maken wij vervolgens een unieke MSR lijst om de MSR gevens aan de eindlijst te kunnen koppelen
Unieke_MSR <- data.frame(MSR_nummer = unique(LS_Hld_PC6$MSR_BEHUIZING))

ML_Unieke_MSR_MS_Stations <- sapply(Unieke_MSR$MSR_nummer, function(x) match(x, MS_Stations$NRBEHUIZIN))

Unieke_MSR$Naam_Ruimte <- MS_Stations$NAAMRUIMTE[ML_Unieke_MSR_MS_Stations]
Unieke_MSR$Vermogen <- MS_Stations$TOTVERMOGE[ML_Unieke_MSR_MS_Stations]
Unieke_MSR$TypeMSR <- MS_Stations$TYPEMSR[ML_Unieke_MSR_MS_Stations]
Unieke_MSR$FunctieMSR <- MS_Stations$GEMEENTE[ML_Unieke_MSR_MS_Stations]
Unieke_MSR$Postcode <- MS_Stations$POSTCODE[ML_Unieke_MSR_MS_Stations]

#Vervolgens deze lijst koppelen aan de MSR resultaten lijst

ML_Unieke_MSR_aan_Resultaten_MSR <- sapply(MSR_PenGr_EV_H, function(x) match(x, Unieke_MSR$MSR_nummer))

#Nu vervolgens koppelen aan elkaar

MSR_Max_Laag_Scenario <- cbind(Unieke_MSR[ML_Unieke_MSR_aan_Resultaten_MSR,], MSR_Max_Laag_Scenario)

# Als laatste kunnen we deze voorbeeldbestanden opslaan en dit is dan het resultaat

write.table(LS_Max_Laag_Scenario, "Resultaat_MaxBelasting_LS_Hld_Laag.csv", sep = ";", row.names = FALSE)
write.table(MSR_Max_Laag_Scenario, "Resultaat_MaxBelasting_MSR_Laag.csv", sep = ";", row.names = FALSE)

