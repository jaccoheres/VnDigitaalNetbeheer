# Run.R
# This script loads & modifies the K&M and AM data to make it fit for Vision calculations.
# This is the main file to execute for the Bottom Up Net-calculations project. It computes 
# the specific loads per MSR using sparse matrix algebra.
#
# By Werner van Westering MSc.
# Based on code generated by Tim Lucas.
# Start 28-10-2014
#
# "AaaRRRRRR matey! This be t' author's first real R model. HarrRRR HarrRRR HaRRRRR!"
# "So t' script has some pirate talk in it. ARRRRRR be t' pirate language!"
#
# Abbriviations
# KV   = KleinVerbruikers      (Small Users)
# GV   = GrootVerbruikers      (Large Users)
# WP   = WarmtePomp            (Combined Heat and Power (CHP))
# PV   = PhotoVoltaic
# EV   = Electric Vehicles
# HLD  = HoofdLeiDing         (Major LV line) (Headline is the wrong translation ;))
# LSLD = LaagSpanningsLeiDing
# LV   = Low Voltage
# MSR  = MiddenSpanningsRuimte (Medium-to-low voltage transformer room)


##Initialize ----------------------------------------------------------------------
# Remove all data and set working directory
rm(list=ls(all=TRUE))
gc(verbose=FALSE)
path = "C:/1. Programmeerwerk/Bottum Up Analyse/2. Data"
setwd(paste0(path,"/7. Output"))

print("--Loading packages--")
# Load packages
library(reshape2)
library(plyr)
library(data.table)
library(slam)       #Used for sparse matrices
library(tictoc)     #Because I am a Matlab person
library(xlsx)
library(ggplot2)
library(doSNOW)

#Load data (To generate this data: run DataPreparation.R)
print("--Loading data--")
load("Connections_NH_v2.RData")

# Defines function which calculates peak time per MSR
# Function calculates the total year-profile per MSR per scenario per year, and 
# then finds the time at which the load is mimimum and maximum.
# Note: this function only gives back the time at which this happens. The load itself is calculated
# later per base, EV, PV and WP
ParMSRPeaktimeCalculation <- function(iter,nparscenarios) {
  Outputmatrix = matrix(nrow = nMSR,ncol=2*nparscenarios)
  for(ii in 1:nparscenarios) {
    for(MSRii in 1:nMSR) {
      MSRtotalprofile = Allprofiles %*% ScenariosperMSR[MSRii,,(ii+(iter*nparscenarios))]
      Outputmatrix[MSRii,ii]               = which.max(MSRtotalprofile)          #peaktime
      Outputmatrix[MSRii,nparscenarios+ii] = which.min(MSRtotalprofile)          #peaktimemin
    }  
  }
  return(Outputmatrix)
}

# Initialise matrices which will hold the peak time and minimum peak time (feedin) per MSR
MSRpeaktimetemp = matrix(nrow = nMSR, ncol = 2*nscenarios)
MSRpeaktime = matrix(nrow = nMSR, ncol = nscenarios)
MSRpeaktimemin = matrix(nrow = nMSR, ncol = nscenarios)

print("--Calculating peak time per MSR--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
nparscenarios = nscenarios/nCPUs
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
tic()
MSRpeaktimetemp = foreach(iter = 0:(nCPUs-1), 
                          .packages='slam', 
                          .combine=cbind,
                          .verbose=FALSE) %dopar% {ParMSRPeaktimeCalculation(iter,nparscenarios)}

toc()
stopCluster(cl)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist = rep(c(rep(TRUE,nPVscen*nWPscen*nyears),rep(FALSE,nPVscen*nWPscen*nyears)),nCPUs)
MSRpeaktime = MSRpeaktimetemp[,indexlist]
MSRpeaktimemin = MSRpeaktimetemp[,!indexlist]
rm(MSRpeaktimetemp)

print("--Calculating peak time per HLD--")
# Peak time per HLD is calculated by using MSRtoHLD interconnection matrices
tic()
HLDpeaktime = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime)
HLDpeaktimemin = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin)
toc()

# Based on the peak times, the minimum and maximum load is then found.
print("--Calculate load per HLD and mSR--")
# Initialise  matrices
MSRload    = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin = matrix(nrow = 4*nMSR, ncol = nscenarios)
tempMSR    = matrix(nrow = nMSR, ncol = nprofiles)
HLDload    = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin = matrix(nrow = 4*nHLD, ncol = nscenarios)
tempHLD    = matrix(nrow = nHLD, ncol = nprofiles)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
  setTxtProgressBar(progressbar,ii)
  
  # For each scenario, we find the load from Allprofiles which corresponds with the peak time per MSR 
  # and multiply this element wise with a vector containing [SJV,nEV,nPV,nWP]
  # This gives a matrix tempMSR with dimension [nMSR * nprofiles]
  # in the second step, this matrix is truncated so that different profiles which correspond to the same load
  # (e.g. 10 EDSN profiles which all correspond to the 'base' load) are summed up into 1 value
  
  #peak load per MSR  
  tempMSR = Allprofiles[MSRpeaktime[,ii],] * ScenariosperMSR[,,ii]
  tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
  MSRload[,ii] = c(tempMSR)
  
  #minimum peak load per MSR (=maximum feedin)
  tempMSR = Allprofiles[MSRpeaktimemin[,ii],] * ScenariosperMSR[,,ii]
  tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
  MSRloadmin[,ii] = c(tempMSR)
  
  #peak load per HLD 
  tempHLD = Allprofiles[HLDpeaktime[,ii],] * ScenariosperHLD[,,ii]
  tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])
  HLDload[,ii] = c(tempHLD)
  
  #minimum load per HLD (=maximum feedin)
  tempHLD = Allprofiles[HLDpeaktimemin[,ii],] * ScenariosperHLD[,,ii]
  tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])  
  HLDloadmin[,ii] = c(tempHLD)
  
}
toc()
close(progressbar)
rm(tempHLD,tempMSR)

######################################################### Save results
print("--Saving results--")
setwd(paste0(path,"/7. Output"))

# Save necessary data
save.image("CalculationOutput_NH_v2.RData")
print("--Done!--")

# ##################################Generate a quick (&dirty) plot
# factor = seq(0,30,length=50)           # Newbaseload = baseload * factor
# outcome = numeric(length(factor))
# 
# # For every factor, check the number of overloaded MSR
# for (ii in 1:length(factor)){
#    print(ii)
#    outcome[ii] = table(MSRmax!=0&((MSRload[,1]+MSRloadGV)*factor[ii])>MSRmax)[2]
# }
# d1<-data.frame(basefactor=factor,overbelast=outcome)
# theme_set(theme_gray(base_size = 18)) # vergrooten lettergroottes
# 
# # Write a png
# setwd("C:/Programmeerwerk/Data")
# png("overbelast.png",width=800, height=500)
# qplot(factor,outcome,xlab="Baseload (1 = nu)",ylab="Aantal overbelaste MSR",geom='line',
#       col=I('blue'),size=1,legend=F,main="Overbelaste MSR versus toename baseload")
# geom_line(aes(factor, outcome, colour=I('red')), d1)
# dev.off()

# For reference, code from Werner van Westering
# # scenarios = cbind(base,PVall[,35:51]*PVpeak+EVall[,35:51]*EVpeak+WPall[,35:51]*WPpeak)
# 
# # Calculate loads
# print("--Doing calculations--")
# #Calculate the loads of the whole network
# tic()
# LSLDload     = matprod_simple_triplet_matrix(PC6toLSLD, scenario)    #Calculate LSLD loads
# MSRload      = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDload)    #Calculate MSR loads
# MSRloadGV    = matprod_simple_triplet_matrix(GVtoMSR, GVuse)         #Calculate GV MSR loads
# HLDload      = matprod_simple_triplet_matrix(PC6toHLD, scenario)     #Calculate HLD loads
# #LSLDloadmin  = matprod_simple_triplet_matrix(PC6toLSLD, scenariomin) #Calculate LSLD loads
# #MSRloadmin   = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDloadmin) #Calculate MSR loads
# #MSRloadGVmin = MSRloadGV                                             #Calculate GV MSR loads
# #HLDloadmin   = matprod_simple_triplet_matrix(PC6toHLD, scenariomin)  #Calculate HLD loads
# toc()
# #Elegant, isn't it?
# 
# #Add GV results to KV results
# MSRload[,seq(1,4*nscenarios,by=4)] = MSRload[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGV,nscenarios)
# MSRloadmin[,seq(1,4*nscenarios,by=4)] = MSRloadmin[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGVmin,nscenarios)
# 
# #Check and count capacity problems
# #table(MSRload[,1]>MSRmax)
# #table(MSRmax!=0&MSRload[,1]>MSRmax)
# # table(HLDmax!=0&HLDload[,1]>HLDmax)