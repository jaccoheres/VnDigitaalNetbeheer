# Run.R
# This script loads & modifies the K&M and AM data to make it fit for Vision calculations.
# This is the main file to execute for the Bottom Up Net-calculations project. It computes 
# the specific loads per MSR using sparse matrix algebra.
# 
# By Werner van Westering MSc.
# Based on code generated by Tim Lucas.
# Start 28-10-2014
#
# "AaaRRRRRR matey! This be t' author's first real R model. HarrRRR HarrRRR HaRRRRR!"
# "So t' script has some pirate talk in it. ARRRRRR be t' pirate language!"
#
# Abbriviations
# KV   = KleinVerbruikers      (Small Users)
# GV   = GrootVerbruikers      (Large Users)
# WP   = WarmtePomp            (Combined Heat and Power (CHP))
# PV   = PhotoVoltaic
# EV   = Electric Vehicles
# HLD  = HoofdLeiDing         (Major LV line) (Headline is the wrong translation ;))
# LSLD = LaagSpanningsLeiDing
# OSLD = OnderStationsLeiDing
# LV   = Low Voltage
# MSR  = MiddenSpanningsRuimte (Medium-to-low voltage transformer room)


##Initialize ----------------------------------------------------------------------
# Remove all data and set working directory
rm(list=ls(all=TRUE))
gc(verbose=FALSE)
drive = substr(getwd(),1,3)
path = paste0(drive,"1. Programmeerwerk/Bottum Up Analyse/2. Data")
setwd(paste0(path,"/7. Output"))

print("--Loading packages--")
# Load packages
library(reshape2)
library(plyr)
library(data.table)
library(slam)       #Used for sparse matrices
library(tictoc)     #Because I am a Matlab person
# library(xlsx)
library(ggplot2)
library(doSNOW)
library(utils)


#Load data (To generate this data: run DataPreparation.R)
print("--Loading data--")
load("Connections_NH_v2.RData")
drive = substr(getwd(),1,3)
path = paste0(drive,"1. Programmeerwerk/Bottum Up Analyse/2. Data")
nCPUs = 8
print("--Defining functions (1/3)--")
# Defines function which calculates peak time per MSR
# Function calculates the total year-profile per MSR per scenario per year, and 
# then finds the time at which the load is mimimum and maximum.
# Note: this function only gives back the time at which this happens. The load itself is calculated
# later per base, EV, PV and WP

ParPeaktimeCalculationperAsset <- function(iter,nparassets,baseloadperAsset,KVScenariosperAsset,AllKVtechprofiles,GVScenariosperAsset,AllGVtechprofiles) {
  Outputmatrix = matrix(nrow = nparassets,ncol=2*nscenarios)
  if(length(dim(GVScenariosperAsset))==2) {GVScenariosperAsset = array(GVScenariosperAsset,c(nparassets,1,nscenarios))}
  # setTxtProgressBar(pb, iter)
  for(Assetii in 1:nparassets) { 
    tempbaseload = baseloadperAsset[Assetii,]
    for(ii in 1:nscenarios) {
      Assettotalprofile = tempbaseload  +
        AllKVtechprofiles %*% KVScenariosperAsset[Assetii,,ii] +
        AllGVtechprofiles %*% GVScenariosperAsset[Assetii,,ii] 
      Outputmatrix[Assetii,ii]               = which.max(Assettotalprofile)          #peaktime
      Outputmatrix[Assetii,nscenarios+ii]    = which.min(Assettotalprofile)          #peaktimemin
    }  
  }
  return(Outputmatrix)
}
# iter = 0
# nparassets = 1+parassetindex[iter+1,2]-parassetindex[iter+1,1]
# baseloadperAsset = baseloadperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),]
# KVScenariosperAsset = KVScenariosperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,]
# GVScenariosperAsset = GVScenariosperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,]

FindLoadperAsset <- function(baseloadperAsset,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperAsset,GVScenariosperAsset,peaktimeperAsset) {
  nAssets                  = length(peaktimeperAsset)
  Assetload                = matrix(NA,nAssets,4)
  KVtempAsset              = AllKVtechprofiles[peaktimeperAsset,] * KVScenariosperAsset
  
  if(!is.null(GVScenariosperAsset)) {
    if(is.null(dim(GVScenariosperAsset))) {GVScenariosperAsset = matrix(GVScenariosperAsset,nAssets,1)}
    GVtempAsset = AllGVtechprofiles[peaktimeperAsset,] * GVScenariosperAsset
  } else {
    GVtempAsset = rep(0,nAssets)
  }
  
  indexmatrix              = matrix(c(1:nAssets,peaktimeperAsset),nAssets,2)
  Assetload[,baseorder]    = baseloadperAsset[indexmatrix]
  Assetload[,EVorder]      = rowSums(KVtempAsset[,KVEVindex]) + GVtempAsset
  Assetload[,PVorder]      = KVtempAsset[,KVPVindex]
  Assetload[,WPorder]      = KVtempAsset[,KVWPindex] 
  Assetload                = c(Assetload)
  rm(KVtempAsset,GVtempAsset)
  return(Assetload)
}

print("--Calculation based on peaktime per MSR (2/3)--")
# Initialise matrices which will hold the peak time and minimum peak time (feedin) per MSR 
MSRpeaktimetemp      = matrix(nrow = nMSR,  ncol = 2*nscenarios)
MSRpeaktime_MSR      = matrix(nrow = nMSR,  ncol = nscenarios)
MSRpeaktimemin_MSR   = matrix(nrow = nMSR,  ncol = nscenarios)
HLDpeaktime_MSR      = matrix(nrow = nHLD,  ncol = nscenarios)
HLDpeaktimemin_MSR   = matrix(nrow = nHLD,  ncol = nscenarios)
OSLDpeaktime_MSR     = matrix(nrow = nOSLD, ncol = nscenarios)
OSLDpeaktimemin_MSR  = matrix(nrow = nOSLD, ncol = nscenarios)

print("--> Calculating peak times in network per MSR (2a/3)--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
#nparscenarios = nscenarios/nCPUs       #NEED FIX: Does not work if nscenarios/nCPUs is not an integer
iter = 0:(nCPUs-1)
nparassets = nMSR %/% nCPUs
parassetindex = matrix(NA,nCPUs,2)
for (i in iter) {parassetindex[i+1,] = cbind((i*nparassets+1),(i+1)*nparassets)}
parassetindex[nCPUs,2] = parassetindex[nCPUs,2]+ (nMSR %% nCPUs)
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
pb = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
MSRpeaktimetemp = foreach(iter = 0:(nCPUs-1), .packages='slam', .combine=rbind, .verbose=FALSE) %dopar% {
  ParPeaktimeCalculationperAsset(iter,1+parassetindex[iter+1,2]-parassetindex[iter+1,1],baseloadperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),],KVScenariosperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,],AllKVtechprofiles,GVScenariosperMSR[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,],AllGVtechprofiles)
}

toc()
stopCluster(cl)
close(pb)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist          = c(rep(TRUE,nscenarios),rep(FALSE,nscenarios))
MSRpeaktime_MSR    = MSRpeaktimetemp[,indexlist]
MSRpeaktimemin_MSR = MSRpeaktimetemp[,!indexlist]
rm(MSRpeaktimetemp)

print("--> Cascading peak times per MSR to HLDs (2b/3)--")
# Peak time per HLD is calculated by using MSRtoHLD interconnection matrices
# TO DO!! Account for HLDs which are connected to multiple MSRs
tic()
HLDpeaktime_MSR     = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_MSR)
HLDpeaktimemin_MSR  = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_MSR)
toc()

print("--> Calculating loads per MSR and HLD based on peak times per MSR (2c/3)--")
# Based on the peak times, the minimum and maximum load is then found.
# Initialise  matrices
OSLDload_MSR      = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_MSR   = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_MSR       = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_MSR    = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_MSR       = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_MSR    = matrix(nrow = 4*nHLD, ncol = nscenarios)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
  setTxtProgressBar(progressbar,ii)
  
  # For each scenario, we find the load from AllKVprofiles which corresponds with the peak time per MSR 
  # and multiply this element wise with a vector containing [nEV,nPV,nWP]
  # This gives a matrix tempMSR with dimension [nMSR * ntechprofiles]
  
  #peak load per MSR 
  MSRload_MSR[,ii]    = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktime_MSR[,ii])
  MSRloadmin_MSR[,ii] = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktimemin_MSR[,ii])
  #peak load per HLD
  HLDload_MSR[,ii]    = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],NULL,HLDpeaktime_MSR[,ii])   
  HLDloadmin_MSR[,ii] = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],NULL,HLDpeaktimemin_MSR[,ii])      
}
toc()
close(progressbar)

print("--> Calculating loads per OSLD based on peak times per MSR (2d/3)--")
# OSLD load is calculated using MSRtoOSLD matrices
# Note: this is only for checking purposes in the model, to check loads per OSLD based on 
# MSR peak time calculations, versus loads per OSLD based on OSLD peak time calculations
indexlist_MSR  = rep(c(TRUE,FALSE,FALSE,FALSE),nMSR)
indexlist_OSLD = rep(c(TRUE,FALSE,FALSE,FALSE),nOSLD)
for (i in 1:4) {
  tempMSRload                       = MSRload_MSR[indexlist_MSR,]
  OSLDload_MSR[indexlist_OSLD,]     = matprod_simple_triplet_matrix(MSRtoOSLD,tempMSRload)
  tempMSRload                       = MSRloadmin_MSR[indexlist_MSR,]
  OSLDloadmin_MSR[indexlist_OSLD,]  = matprod_simple_triplet_matrix(MSRtoOSLD,tempMSRload)
  indexlist_MSR = c(FALSE,indexlist_MSR[-length(indexlist_MSR)])
  indexlist_OSLD = c(FALSE,indexlist_OSLD[-length(indexlist_OSLD)])
}

print("--Calculating peak times in network per OSLD--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
# nparscenarios = nscenarios/nCPUs
# cl<-makeCluster(nCPUs) 
# registerDoSNOW(cl)
# pb = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
# tic()
# OSLDpeaktimetemp = foreach(iter = 0:(nCPUs-1), .packages='slam', .combine=cbind,.verbose=FALSE) %dopar% {
#   ParPeaktimeCalculationperAsset(iter,nparscenarios,baseloadperOSLD,KVScenariosperOSLD,AllKVtechprofiles,GVScenariosperOSLD,AllGVtechprofiles)
# }
# toc()
# stopCluster(cl)
# close(pb)

iter = 0:(nCPUs-1)
nparassets = nOSLD %/% nCPUs
parassetindex = matrix(NA,nCPUs,2)
for (i in iter) {parassetindex[i+1,] = cbind((i*nparassets+1),(i+1)*nparassets)}
parassetindex[nCPUs,2] = parassetindex[nCPUs,2]+ (nOSLD %% nCPUs)
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
pb = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
OSLDpeaktimetemp = foreach(iter = 0:(nCPUs-1), .packages='slam', .combine=rbind, .verbose=FALSE) %dopar% {
  ParPeaktimeCalculationperAsset(iter,1+parassetindex[iter+1,2]-parassetindex[iter+1,1],baseloadperOSLD[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),],KVScenariosperOSLD[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,],AllKVtechprofiles,GVScenariosperOSLD[(parassetindex[iter+1,1]:parassetindex[iter+1,2]),,],AllGVtechprofiles)
}

toc()
stopCluster(cl)
close(pb)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist = c(rep(TRUE,nscenarios),rep(FALSE,nscenarios))
OSLDpeaktime_OSLD    = OSLDpeaktimetemp[,indexlist]
OSLDpeaktimemin_OSLD = OSLDpeaktimetemp[,!indexlist]
rm(OSLDpeaktimetemp)

# Peak time per MSR and HLD is calculated by using OSLDtoMSR and MSRtoHLD interconnection matrices
tic()
MSRpeaktime_OSLD                            = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktime_OSLD)
MSRpeaktimemin_OSLD                         = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktimemin_OSLD)
MSRpeaktime_OSLD[MSRpeaktime_OSLD==0]       = NA #not all MSRs have an OSLD
MSRpeaktimemin_OSLD[MSRpeaktimemin_OSLD==0] = NA #not all MSRs have an OSLD
HLDpeaktime_OSLD                            = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_OSLD)
HLDpeaktimemin_OSLD                         = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_OSLD)
toc()

# Based on the peak times, the minimum and maximum load is then found.
print("--Calculate loads in network per OSLD--")
# Initialise  matrices
OSLDload_OSLD    = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_OSLD = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_OSLD     = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_OSLD  = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_OSLD     = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_OSLD  = matrix(nrow = 4*nHLD, ncol = nscenarios)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
  setTxtProgressBar(progressbar,ii)
  
  # For each scenario, we find the load from AllKVprofiles which corresponds with the peak time per MSR 
  # and multiply this element wise with a vector containing [SJV,nEV,nPV,nWP]
  # This gives a matrix tempMSR with dimension [nMSR * nprofiles]
  # in the second step, this matrix is truncated so that different profiles which correspond to the same load
  # (e.g. 10 EDSN profiles which all correspond to the 'base' load) are summed up into 1 value
  
  #peak load per OSLD 
  OSLDload_OSLD[,ii]    = FindLoadperAsset(baseloadperOSLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperOSLD[,,ii],GVScenariosperOSLD[,,ii],OSLDpeaktime_OSLD[,ii])
  OSLDloadmin_OSLD[,ii] = FindLoadperAsset(baseloadperOSLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperOSLD[,,ii],GVScenariosperOSLD[,,ii],OSLDpeaktimemin_OSLD[,ii])
  #peak load per MSR 
  MSRload_OSLD[,ii]     = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktime_OSLD[,ii])
  MSRloadmin_OSLD[,ii]  = FindLoadperAsset(baseloadperMSR,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperMSR[,,ii],GVScenariosperMSR[,,ii],MSRpeaktimemin_OSLD[,ii])
  #peak load per HLD
  HLDload_OSLD[,ii]     = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],NULL,HLDpeaktime_OSLD[,ii])   
  HLDloadmin_OSLD[,ii]  = FindLoadperAsset(baseloadperHLD,AllKVtechprofiles,AllGVtechprofiles,KVScenariosperHLD[,,ii],NULL,HLDpeaktimemin_OSLD[,ii])     
}
toc()
close(progressbar)

# Fix for multiple HLD connections



######################################################### Save results
print("--Saving results--")
setwd(paste0(path,"/7. Output"))

# Save necessary data
save.image("CalculationOutput_NH_v2.RData")
print("--Done!--")

# ##################################Generate a quick (&dirty) plot
# factor = seq(0,30,length=50)           # Newbaseload = baseload * factor
# outcome = numeric(length(factor))
# 
# # For every factor, check the number of overloaded MSR
# for (ii in 1:length(factor)){
#    print(ii)
#    outcome[ii] = table(MSRmax!=0&((MSRload[,1]+MSRloadGV)*factor[ii])>MSRmax)[2]
# }
# d1<-data.frame(basefactor=factor,overbelast=outcome)
# theme_set(theme_gray(base_size = 18)) # vergrooten lettergroottes
# 
# # Write a png
# setwd("C:/Programmeerwerk/Data")
# png("overbelast.png",width=800, height=500)
# qplot(factor,outcome,xlab="Baseload (1 = nu)",ylab="Aantal overbelaste MSR",geom='line',
#       col=I('blue'),size=1,legend=F,main="Overbelaste MSR versus toename baseload")
# geom_line(aes(factor, outcome, colour=I('red')), d1)
# dev.off()

###### For reference, peak time calculations per individual asset
#
# ParPeaktimeCalculationperMSR <- function(iter,nparscenarios) {
#    Outputmatrix = matrix(nrow = nMSR,ncol=2*nparscenarios)
#    setTxtProgressBar(pb, iter)
#    for(ii in 1:nparscenarios) {
#       for(MSRii in 1:nMSR) {
#          MSRtotalprofile = AllKVprofiles %*% ScenariosperMSR[MSRii,,(ii+(iter*nparscenarios))] + GVuse[MSRii,]
#          Outputmatrix[MSRii,ii]               = which.max(MSRtotalprofile)          #peaktime
#          Outputmatrix[MSRii,nparscenarios+ii] = which.min(MSRtotalprofile)          #peaktimemin
#       }  
#    }
#    return(Outputmatrix)
# }
# 
# # Same as above but now per OS field
# ParPeaktimeCalculationperOSLD <- function(iter,nparscenarios) {
#    Outputmatrix = matrix(nrow = nOSLD,ncol=2*nparscenarios)
#    setTxtProgressBar(pb, iter)
#    for(ii in 1:nparscenarios) {
#       for(OSLDii in 1:nOSLD) {
#          OSLDtotalprofile = AllKVprofiles %*% ScenariosperOSLD[OSLDii,,(ii+(iter*nparscenarios))] + GVMSRload[Assetii,]
#          Outputmatrix[OSLDii,ii]               = which.max(OSLDtotalprofile)          #peaktime
#          Outputmatrix[OSLDii,nparscenarios+ii] = which.min(OSLDtotalprofile)          #peaktimemin
#       }  
#    }
#    return(Outputmatrix)
# }

# For reference, code from Werner van Westering
# # scenarios = cbind(base,PVall[,35:51]*PVpeak+EVall[,35:51]*EVpeak+WPall[,35:51]*WPpeak)
# 
# # Calculate loads
# print("--Doing calculations--")
# #Calculate the loads of the whole network
# tic()
# LSLDload     = matprod_simple_triplet_matrix(PC6toLSLD, scenario)    #Calculate LSLD loads
# MSRload      = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDload)    #Calculate MSR loads
# MSRloadGV    = matprod_simple_triplet_matrix(GVtoMSR, GVuse)         #Calculate GV MSR loads
# HLDload      = matprod_simple_triplet_matrix(PC6toHLD, scenario)     #Calculate HLD loads
# #LSLDloadmin  = matprod_simple_triplet_matrix(PC6toLSLD, scenariomin) #Calculate LSLD loads
# #MSRloadmin   = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDloadmin) #Calculate MSR loads
# #MSRloadGVmin = MSRloadGV                                             #Calculate GV MSR loads
# #HLDloadmin   = matprod_simple_triplet_matrix(PC6toHLD, scenariomin)  #Calculate HLD loads
# toc()
# #Elegant, isn't it?
# 
# #Add GV results to KV results
# MSRload[,seq(1,4*nscenarios,by=4)] = MSRload[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGV,nscenarios)
# MSRloadmin[,seq(1,4*nscenarios,by=4)] = MSRloadmin[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGVmin,nscenarios)
# 
# #Check and count capacity problems
# #table(MSRload[,1]>MSRmax)
# #table(MSRmax!=0&MSRload[,1]>MSRmax)
# # table(HLDmax!=0&HLDload[,1]>HLDmax)