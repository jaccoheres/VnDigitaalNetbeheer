# Run.R
# This script loads & modifies the K&M and AM data to make it fit for Vision calculations.
# This is the main file to execute for the Bottom Up Net-calculations project. It computes 
# the specific loads per MSR using sparse matrix algebra.
# 
# By Werner van Westering MSc.
# Based on code generated by Tim Lucas.
# Start 28-10-2014
#
# "AaaRRRRRR matey! This be t' author's first real R model. HarrRRR HarrRRR HaRRRRR!"
# "So t' script has some pirate talk in it. ARRRRRR be t' pirate language!"
#
# Abbriviations
# KV   = KleinVerbruikers      (Small Users)
# GV   = GrootVerbruikers      (Large Users)
# WP   = WarmtePomp            (Combined Heat and Power (CHP))
# PV   = PhotoVoltaic
# EV   = Electric Vehicles
# HLD  = HoofdLeiDing         (Major LV line) (Headline is the wrong translation ;))
# LSLD = LaagSpanningsLeiDing
# LV   = Low Voltage
# MSR  = MiddenSpanningsRuimte (Medium-to-low voltage transformer room)


##Initialize ----------------------------------------------------------------------
# Remove all data and set working directory
rm(list=ls(all=TRUE))
gc(verbose=FALSE)
path = "C:/1. Programmeerwerk/Bottum Up Analyse/2. Data"
setwd(paste0(path,"/7. Output"))

print("--Loading packages--")
# Load packages
library(reshape2)
library(plyr)
library(data.table)
library(slam)       #Used for sparse matrices
library(tictoc)     #Because I am a Matlab person
library(xlsx)
library(ggplot2)
library(doSNOW)

#Load data (To generate this data: run DataPreparation.R)
print("--Loading data--")
load("Connections_NH_v2.RData")

# Defines function which calculates peak time per MSR
# Function calculates the total year-profile per MSR per scenario per year, and 
# then finds the time at which the load is mimimum and maximum.
# Note: this function only gives back the time at which this happens. The load itself is calculated
# later per base, EV, PV and WP
ParPeaktimeCalculationperMSR <- function(iter,nparscenarios) {
  Outputmatrix = matrix(nrow = nMSR,ncol=2*nparscenarios)
  for(ii in 1:nparscenarios) {
    for(MSRii in 1:nMSR) {
      MSRtotalprofile = Allprofiles %*% ScenariosperMSR[MSRii,,(ii+(iter*nparscenarios))]
      Outputmatrix[MSRii,ii]               = which.max(MSRtotalprofile)          #peaktime
      Outputmatrix[MSRii,nparscenarios+ii] = which.min(MSRtotalprofile)          #peaktimemin
    }  
  }
  return(Outputmatrix)
}

# Same as above but now per OS field
ParPeaktimeCalculationperOSLD <- function(iter,nparscenarios) {
   Outputmatrix = matrix(nrow = nOSLD,ncol=2*nparscenarios)
   for(ii in 1:nparscenarios) {
      for(OSLDii in 1:nOSLD) {
         OSLDtotalprofile = Allprofiles %*% ScenariosperOSLD[OSLDii,,(ii+(iter*nparscenarios))]
         Outputmatrix[OSLDii,ii]               = which.max(OSLDtotalprofile)          #peaktime
         Outputmatrix[OSLDii,nparscenarios+ii] = which.min(OSLDtotalprofile)          #peaktimemin
      }  
   }
   return(Outputmatrix)
}

# Initialise matrices which will hold the peak time and minimum peak time (feedin) per MSR 
MSRpeaktimetemp      = matrix(nrow = nMSR, ncol = 2*nscenarios)
MSRpeaktime_MSR      = matrix(nrow = nMSR, ncol = nscenarios)
MSRpeaktimemin_MSR   = matrix(nrow = nMSR, ncol = nscenarios)
HLDpeaktime_MSR      = matrix(nrow = nHLD, ncol = nscenarios)
HLDpeaktimemin_MSR   = matrix(nrow = nHLD, ncol = nscenarios)
OSLDpeaktime_MSR     = matrix(nrow = nOSLD, ncol = nscenarios)
OSLDpeaktimemin_MSR  = matrix(nrow = nOSLD, ncol = nscenarios)

print("--Calculating peak timeS in network per MSR--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
nparscenarios = nscenarios/nCPUs
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
tic()
MSRpeaktimetemp = foreach(iter = 0:(nCPUs-1), 
                          .packages='slam', 
                          .combine=cbind,
                          .verbose=FALSE) %dopar% {ParPeaktimeCalculationperMSR(iter,nparscenarios)}

toc()
stopCluster(cl)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist = rep(c(rep(TRUE,nPVscen*nWPscen*nyears),rep(FALSE,nPVscen*nWPscen*nyears)),nCPUs)
MSRpeaktime_MSR    = MSRpeaktimetemp[,indexlist]
MSRpeaktimemin_MSR = MSRpeaktimetemp[,!indexlist]
rm(MSRpeaktimetemp)

# Peak time per OSLD and HLD is calculated by using MSRtoOSLD and MSRtoHLD interconnection matrices
tic()
HLDpeaktime_MSR   = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_MSR)
HLDpeaktimemin_MSR  = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_MSR)
OSLDpeaktime_MSR    = matprod_simple_triplet_matrix(MSRtoOSLD,MSRpeaktime_MSR)
OSLDpeaktimemin_MSR = matprod_simple_triplet_matrix(MSRtoOSLD,MSRpeaktimemin_MSR)
toc()

# Based on the peak times, the minimum and maximum load is then found.
print("--Calculate loads in network per MSR--")
# Initialise  matrices
tempOSLD        = matrix(nrow = nMSR, ncol = nprofiles)
tempMSR         = matrix(nrow = nMSR, ncol = nprofiles)
tempHLD         = matrix(nrow = nHLD, ncol = nprofiles)
OSLDload_MSR    = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_MSR = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_MSR     = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_MSR  = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_MSR     = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_MSR  = matrix(nrow = 4*nHLD, ncol = nscenarios)


# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
  setTxtProgressBar(progressbar,ii)
  
  # For each scenario, we find the load from Allprofiles which corresponds with the peak time per MSR 
  # and multiply this element wise with a vector containing [SJV,nEV,nPV,nWP]
  # This gives a matrix tempMSR with dimension [nMSR * nprofiles]
  # in the second step, this matrix is truncated so that different profiles which correspond to the same load
  # (e.g. 10 EDSN profiles which all correspond to the 'base' load) are summed up into 1 value

  #peak load per OSLD  
  tempOSLD = Allprofiles[OSLDpeaktime_MSR[,ii],] * ScenariosperOSLD[,,ii]
  tempOSLD = cbind(rowSums(tempOSLD[,baseprofileindex]),tempOSLD[,EVprofileindex],tempOSLD[,PVprofileindex],tempOSLD[,WPprofileindex])
  OSLDload_MSR[,ii] = c(tempOSLD)
  
  #minimum peak load per OSLD (=maximum feedin)
  tempOSLD = Allprofiles[OSLDpeaktimemin_MSR[,ii],] * ScenariosperOSLD[,,ii]
  tempOSLD = cbind(rowSums(tempOSLD[,baseprofileindex]),tempOSLD[,EVprofileindex],tempOSLD[,PVprofileindex],tempOSLD[,WPprofileindex])
  OSLDloadmin_MSR[,ii] = c(tempOSLD)
  
  #peak load per MSR  
  tempMSR = Allprofiles[MSRpeaktime_MSR[,ii],] * ScenariosperMSR[,,ii]
  tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
  MSRload_MSR[,ii] = c(tempMSR)
  
  #minimum peak load per MSR (=maximum feedin)
  tempMSR = Allprofiles[MSRpeaktimemin_MSR[,ii],] * ScenariosperMSR[,,ii]
  tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
  MSRloadmin_MSR[,ii] = c(tempMSR)
  
  #peak load per HLD 
  tempHLD = Allprofiles[HLDpeaktime_MSR[,ii],] * ScenariosperHLD[,,ii]
  tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])
  HLDload_MSR[,ii] = c(tempHLD)
  
  #minimum load per HLD (=maximum feedin)
  tempHLD = Allprofiles[HLDpeaktimemin_MSR[,ii],] * ScenariosperHLD[,,ii]
  tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])  
  HLDloadmin_MSR[,ii] = c(tempHLD)
  
}
toc()
close(progressbar)
rm(tempOSLD,tempHLD,tempMSR)

# Initialise matrices which will hold the peak time and minimum peak time (feedin) per OSLD 
OSLDpeaktimetemp      = matrix(nrow = nOSLD, ncol = 2*nscenarios)
OSLDpeaktime_OSLD     = matrix(nrow = nOSLD, ncol = nscenarios)
OSLDpeaktimemin_OSLD  = matrix(nrow = nOSLD, ncol = nscenarios)
MSRpeaktime_OSLD      = matrix(nrow = nMSR, ncol = nscenarios)
MSRpeaktimemin_OSLD   = matrix(nrow = nMSR, ncol = nscenarios)
HLDpeaktime_OSLD      = matrix(nrow = nHLD, ncol = nscenarios)
HLDpeaktimemin_OSLD   = matrix(nrow = nHLD, ncol = nscenarios)

print("--Calculating peak timeS in network per OSLD--")
# Function is called using full number of CPUs set in DataPreparation.R
# Rerun DataPreparation to override, manually set "nCPU" in the context of this script
nparscenarios = nscenarios/nCPUs
cl<-makeCluster(nCPUs) 
registerDoSNOW(cl)
tic()
OSLDpeaktimetemp = foreach(iter = 0:(nCPUs-1), 
                          .packages='slam', 
                          .combine=cbind,
                          .verbose=FALSE) %dopar% {ParPeaktimeCalculationperOSLD(iter,nparscenarios)}

toc()
stopCluster(cl)

# Because peaktimes are processed parallelly, we need to re-order the columns.
# Results are returned as [i1_Peaktime,i1_Peaktimemin,i2_peaktime,i2_peaktimemin,...]
# Results are re-ordered below and stored in two separate matrices
indexlist = rep(c(rep(TRUE,nPVscen*nWPscen*nyears),rep(FALSE,nPVscen*nWPscen*nyears)),nCPUs)
OSLDpeaktime_OSLD    = OSLDpeaktimetemp[,indexlist]
OSLDpeaktimemin_OSLD = OSLDpeaktimetemp[,!indexlist]
rm(OSLDpeaktimetemp)

# Peak time per MSR and HLD is calculated by using OSLDtoMSR and MSRtoHLD interconnection matrices
tic()
MSRpeaktime_OSLD    = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktime_OSLD)
MSRpeaktimemin_OSLD = matprod_simple_triplet_matrix(OSLDtoMSR,OSLDpeaktimemin_OSLD)
HLDpeaktime_OSLD    = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktime_OSLD)
HLDpeaktimemin_OSLD = matprod_simple_triplet_matrix(MSRtoHLD,MSRpeaktimemin_OSLD)
toc()

# Based on the peak times, the minimum and maximum load is then found.
print("--Calculate loads in network per OSLD--")
# Initialise  matrices
tempOSLD         = matrix(nrow = nOSLD, ncol = nprofiles)
tempMSR          = matrix(nrow = nMSR, ncol = nprofiles)
tempHLD          = matrix(nrow = nHLD, ncol = nprofiles)
OSLDload_OSLD    = matrix(nrow = 4*nOSLD, ncol = nscenarios)
OSLDloadmin_OSLD = matrix(nrow = 4*nOSLD, ncol = nscenarios)
MSRload_OSLD     = matrix(nrow = 4*nMSR, ncol = nscenarios)
MSRloadmin_OSLD  = matrix(nrow = 4*nMSR, ncol = nscenarios)
HLDload_OSLD     = matrix(nrow = 4*nHLD, ncol = nscenarios)
HLDloadmin_OSLD  = matrix(nrow = 4*nHLD, ncol = nscenarios)

# Because we already have the peak times, no matrix multiplications are required here,
# only element-wise multiplications of profile[peaktime]*[SJV,nEV,nPV,nWP]
progressbar = txtProgressBar(min = 0, max = nscenarios, initial = 0, char = "=", style = 3)
tic()
for(ii in 1:nscenarios) {
   setTxtProgressBar(progressbar,ii)
   
   # For each scenario, we find the load from Allprofiles which corresponds with the peak time per MSR 
   # and multiply this element wise with a vector containing [SJV,nEV,nPV,nWP]
   # This gives a matrix tempMSR with dimension [nMSR * nprofiles]
   # in the second step, this matrix is truncated so that different profiles which correspond to the same load
   # (e.g. 10 EDSN profiles which all correspond to the 'base' load) are summed up into 1 value
   
   #peak load per OSLD  
   tempOSLD = Allprofiles[OSLDpeaktime_OSLD[,ii],] * ScenariosperOSLD[,,ii]
   tempOSLD = cbind(rowSums(tempOSLD[,baseprofileindex]),tempOSLD[,EVprofileindex],tempOSLD[,PVprofileindex],tempOSLD[,WPprofileindex])
   OSLDload_OSLD[,ii] = c(tempOSLD)
   
   #minimum peak load per OSLD (=maximum feedin)
   tempOSLD = Allprofiles[OSLDpeaktimemin_OSLD[,ii],] * ScenariosperOSLD[,,ii]
   tempOSLD = cbind(rowSums(tempOSLD[,baseprofileindex]),tempOSLD[,EVprofileindex],tempOSLD[,PVprofileindex],tempOSLD[,WPprofileindex])
   OSLDloadmin_OSLD[,ii] = c(tempOSLD)
   
   #peak load per MSR  
   tempMSR = Allprofiles[MSRpeaktime_OSLD[,ii],] * ScenariosperMSR[,,ii]
   tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
   MSRload_OSLD[,ii] = c(tempMSR)
   
   #minimum peak load per MSR (=maximum feedin)
   tempMSR = Allprofiles[MSRpeaktimemin_OSLD[,ii],] * ScenariosperMSR[,,ii]
   tempMSR = cbind(rowSums(tempMSR[,baseprofileindex]),tempMSR[,EVprofileindex],tempMSR[,PVprofileindex],tempMSR[,WPprofileindex])
   MSRloadmin_OSLD[,ii] = c(tempMSR)
   
   #peak load per HLD 
   tempHLD = Allprofiles[HLDpeaktime_OSLD[,ii],] * ScenariosperHLD[,,ii]
   tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])
   HLDload_OSLD[,ii] = c(tempHLD)
   
   #minimum load per HLD (=maximum feedin)
   tempHLD = Allprofiles[HLDpeaktimemin_OSLD[,ii],] * ScenariosperHLD[,,ii]
   tempHLD = cbind(rowSums(tempHLD[,baseprofileindex]),tempHLD[,EVprofileindex],tempHLD[,PVprofileindex],tempHLD[,WPprofileindex])  
   HLDloadmin_OSLD[,ii] = c(tempHLD)
   
}
toc()
close(progressbar)
rm(tempOSLD,tempHLD,tempMSR)
######################################################### Save results
print("--Saving results--")
setwd(paste0(path,"/7. Output"))

# Save necessary data
save.image("CalculationOutput_NH_v2.RData")
print("--Done!--")

# ##################################Generate a quick (&dirty) plot
# factor = seq(0,30,length=50)           # Newbaseload = baseload * factor
# outcome = numeric(length(factor))
# 
# # For every factor, check the number of overloaded MSR
# for (ii in 1:length(factor)){
#    print(ii)
#    outcome[ii] = table(MSRmax!=0&((MSRload[,1]+MSRloadGV)*factor[ii])>MSRmax)[2]
# }
# d1<-data.frame(basefactor=factor,overbelast=outcome)
# theme_set(theme_gray(base_size = 18)) # vergrooten lettergroottes
# 
# # Write a png
# setwd("C:/Programmeerwerk/Data")
# png("overbelast.png",width=800, height=500)
# qplot(factor,outcome,xlab="Baseload (1 = nu)",ylab="Aantal overbelaste MSR",geom='line',
#       col=I('blue'),size=1,legend=F,main="Overbelaste MSR versus toename baseload")
# geom_line(aes(factor, outcome, colour=I('red')), d1)
# dev.off()

# For reference, code from Werner van Westering
# # scenarios = cbind(base,PVall[,35:51]*PVpeak+EVall[,35:51]*EVpeak+WPall[,35:51]*WPpeak)
# 
# # Calculate loads
# print("--Doing calculations--")
# #Calculate the loads of the whole network
# tic()
# LSLDload     = matprod_simple_triplet_matrix(PC6toLSLD, scenario)    #Calculate LSLD loads
# MSRload      = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDload)    #Calculate MSR loads
# MSRloadGV    = matprod_simple_triplet_matrix(GVtoMSR, GVuse)         #Calculate GV MSR loads
# HLDload      = matprod_simple_triplet_matrix(PC6toHLD, scenario)     #Calculate HLD loads
# #LSLDloadmin  = matprod_simple_triplet_matrix(PC6toLSLD, scenariomin) #Calculate LSLD loads
# #MSRloadmin   = matprod_simple_triplet_matrix(LSLDtoMSR, LSLDloadmin) #Calculate MSR loads
# #MSRloadGVmin = MSRloadGV                                             #Calculate GV MSR loads
# #HLDloadmin   = matprod_simple_triplet_matrix(PC6toHLD, scenariomin)  #Calculate HLD loads
# toc()
# #Elegant, isn't it?
# 
# #Add GV results to KV results
# MSRload[,seq(1,4*nscenarios,by=4)] = MSRload[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGV,nscenarios)
# MSRloadmin[,seq(1,4*nscenarios,by=4)] = MSRloadmin[,seq(1,4*nscenarios,by=4)]+rep(MSRloadGVmin,nscenarios)
# 
# #Check and count capacity problems
# #table(MSRload[,1]>MSRmax)
# #table(MSRmax!=0&MSRload[,1]>MSRmax)
# # table(HLDmax!=0&HLDload[,1]>HLDmax)